from fastapi import FastAPI, Depends, HTTPException
import asyncio
import logging
import os
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.sql import select, update
from .database import get_db
from .models import Stock, Signal, Subscription
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from .anomaly_detector import detect_anomalies_for_ticker
from datetime import datetime
from moexalgo import Market, Ticker
import httpx
from aiogram import Bot
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()
scheduler = AsyncIOScheduler()

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot = Bot(
    token=os.getenv("BOT_TOKEN"),
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)

# –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–∏–∫–µ—Ä—ã —Å MOEX
def get_all_tickers():
    try:
        market = Market("stocks")
        tickers = market.tickers()
        logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ {len(tickers)} —Ç–∏–∫–µ—Ä–æ–≤ —Å MOEX")
        return [ticker['ticker'] + ".ME" for ticker in tickers]
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —Ç–∏–∫–µ—Ä–æ–≤: {e}")
        return []

TICKERS = get_all_tickers()

@app.on_event("startup")
async def startup_event():
    logger.info("–ó–∞–ø—É—Å–∫ –∫–æ–ª–ª–µ–∫—Ç–æ—Ä–∞...")
    scheduler.start()
    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
    scheduler.add_job(collect_stock_data, "interval", minutes=10)
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö —Å—Ä–∞–∑—É –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
    await collect_stock_data()

@app.on_event("shutdown")
async def shutdown_event():
    logger.info("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã –∫–æ–ª–ª–µ–∫—Ç–æ—Ä–∞...")
    scheduler.shutdown()
    await bot.session.close()

async def collect_stock_data():
    logger.info(f"–ù–∞—á–∞–ª–æ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {len(TICKERS)} —Ç–∏–∫–µ—Ä–æ–≤...")
    async with httpx.AsyncClient(transport=httpx.AsyncHTTPTransport(retries=3)) as client:
        async with get_db() as db:
            for ticker in TICKERS:
                logger.info(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–∏–∫–µ—Ä–∞: {ticker}")
                for attempt in range(1, 4):
                    try:
                        stock = Ticker(ticker.replace(".ME", ""), market=Market('stocks'))
                        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É
                        price_data = stock.price_info()
                        logger.info(f"–î–∞–Ω–Ω—ã–µ –¥–ª—è {ticker}: {price_data}")
                        if not price_data or 'LAST' not in price_data:
                            logger.warning(f"–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {ticker} –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt}")
                            if attempt == 3:
                                continue
                            await asyncio.sleep(2)
                            continue

                        last_price = price_data['LAST']
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ–±—ä—ë–º–∞ —Ç–æ—Ä–≥–æ–≤
                        volume = price_data.get('VOLUME', 0)
                        logger.info(f"–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è {ticker}: —Ü–µ–Ω–∞={last_price}, –æ–±—ä—ë–º={volume}")

                        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–∫—Ü–∏–∏
                        stock_info = stock.info
                        stock_name = stock_info.get('SHORTNAME', ticker) if isinstance(stock_info, dict) else getattr(stock_info, 'shortName', ticker)

                        # –û–±–Ω–æ–≤–ª—è–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞—ë–º –∑–∞–ø–∏—Å—å
                        result = await db.execute(select(Stock).where(Stock.ticker == ticker))
                        stock_entry = result.scalars().first()
                        if stock_entry:
                            await db.execute(
                                update(Stock).where(Stock.ticker == ticker).values(
                                    last_price=last_price,
                                    volume=volume,
                                    updated_at=datetime.utcnow()
                                )
                            )
                            logger.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–∞ –∑–∞–ø–∏—Å—å –¥–ª—è {ticker}")
                        else:
                            new_stock = Stock(
                                ticker=ticker,
                                name=stock_name,
                                last_price=last_price,
                                volume=volume
                            )
                            db.add(new_stock)
                            logger.info(f"–°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –∑–∞–ø–∏—Å—å –¥–ª—è {ticker}")
                        await db.commit()

                        # –ê–Ω–∞–ª–∏–∑ –∞–Ω–æ–º–∞–ª–∏–π
                        try:
                            signal = await detect_anomalies_for_ticker(ticker, last_price, volume, db)
                            if signal:
                                new_signal = Signal(
                                    ticker=ticker,
                                    signal_type=signal["type"],
                                    value=signal["value"]
                                )
                                db.add(new_signal)
                                await db.commit()
                                logger.info(f"–°–æ—Ö—Ä–∞–Ω—ë–Ω —Å–∏–≥–Ω–∞–ª –¥–ª—è {ticker}: {signal}")

                                # –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ –≤ telegram-bot
                                await client.post("https://stock-market-bot.herokuapp.com/signals", json={
                                    "ticker": ticker,
                                    "signal_type": signal["type"],
                                    "value": signal["value"]
                                })
                                logger.info(f"–°–∏–≥–Ω–∞–ª –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ stock-market-bot –¥–ª—è {ticker}")

                                # –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º
                                subscriptions = await db.execute(
                                    select(Subscription).where(Subscription.ticker == ticker)
                                )
                                subscriptions = subscriptions.scalars().all()
                                logger.info(f"–ù–∞–π–¥–µ–Ω–æ {len(subscriptions)} –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –¥–ª—è {ticker}")
                                for sub in subscriptions:
                                    try:
                                        await bot.send_message(
                                            chat_id=sub.user_id,
                                            text=f"üìà –ê–∫—Ü–∏—è <b>{ticker}</b> –≤—ã—Ä–æ—Å–ª–∞ –Ω–∞ –±–æ–ª–µ–µ —á–µ–º 5%! –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: {signal['value']} RUB"
                                        )
                                        logger.info(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {sub.user_id}")
                                    except Exception as e:
                                        logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {sub.user_id}: {e}")
                        except Exception as e:
                            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∞–Ω–æ–º–∞–ª–∏–π –¥–ª—è {ticker}: {e}")
                        break
                    except Exception as e:
                        logger.warning(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {ticker} –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt}: {e}")
                        if attempt == 3:
                            break
                        await asyncio.sleep(2)
    logger.info("–°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∑–∞–≤–µ—Ä—à—ë–Ω")

@app.get("/stocks")
async def get_stocks(db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Stock))
    return result.scalars().all()

@app.get("/stocks/{ticker}")
async def get_stock(ticker: str, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Stock).where(Stock.ticker == ticker))
    stock = result.scalars().first()
    if not stock:
        raise HTTPException(status_code=404, detail="Stock not found")
    return stock

@app.get("/signals")
async def get_signals(ticker: str, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Signal).where(Signal.ticker == ticker))
    signals = result.scalars().all()
    if not signals:
        raise HTTPException(status_code=404, detail="No signals found")
    return signals

@app.get("/health")
async def health_check():
    return {"status": "Collector is running"}